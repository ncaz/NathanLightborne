use bevy::{prelude::*, ui::ui_focus_system};

use follow::TargetFollowingPlugin;
// use level_select::LevelSelectPlugin;
use pause::PausePlugin;
use tooltip::TooltipPlugin;

use crate::{
    asset::LoadResource,
    shared::GameState,
    ui::{
        level_select::LevelSelectPlugin, loading::LoadingUiPlugin, settings::SettingsPlugin,
        speedrun::SpeedrunTimerPlugin, start_menu::StartMenuPlugin,
    },
};

pub mod follow;
pub mod level_select;
mod loading;
mod pause;
pub mod settings;
mod speedrun;
mod start_menu;
pub mod tooltip;

pub struct UiPlugin;

impl Plugin for UiPlugin {
    fn build(&self, app: &mut App) {
        app.register_type::<UiFont>();
        app.load_resource::<UiFont>();
        app.register_type::<UiSfx>();
        app.load_resource::<UiSfx>();
        app.add_plugins(TargetFollowingPlugin);
        app.add_plugins(TooltipPlugin);
        app.add_plugins(PausePlugin);
        app.add_plugins(LoadingUiPlugin);
        app.add_plugins(SpeedrunTimerPlugin);
        app.add_plugins(StartMenuPlugin);
        app.add_plugins(SettingsPlugin);
        app.add_plugins(LevelSelectPlugin);
        app.add_systems(
            PreUpdate,
            button_sfx
                .after(ui_focus_system)
                .run_if(in_state(GameState::Ui)),
        );
        app.add_systems(PreUpdate, trigger_interaction_events.after(button_sfx));
    }
}

#[derive(Resource, Asset, Clone, Reflect)]
#[reflect(Resource)]
pub struct UiSfx {
    #[dependency]
    on_click: Handle<AudioSource>,
    #[dependency]
    on_hover: Handle<AudioSource>,
}

impl FromWorld for UiSfx {
    fn from_world(world: &mut World) -> Self {
        let asset_server = world.resource::<AssetServer>();

        Self {
            on_click: asset_server.load("sfx/click.wav"),
            on_hover: asset_server.load("sfx/hover.wav"),
        }
    }
}

#[derive(Resource, Asset, Clone, Reflect)]
#[reflect(Resource)]
pub struct UiFont {
    #[dependency]
    font: Handle<Font>,
}

impl FromWorld for UiFont {
    fn from_world(world: &mut World) -> Self {
        let asset_server = world.resource::<AssetServer>();

        Self {
            font: asset_server.load("fonts/Outfit-Medium.ttf"),
        }
    }
}

impl UiFont {
    pub fn text_font(&self) -> TextFont {
        TextFont {
            font: self.font.clone(),
            ..default()
        }
    }
}

#[derive(Component)]
pub struct UiButton;

pub fn button_sfx(
    mut commands: Commands,
    q_button: Query<&Interaction, (With<UiButton>, Changed<Interaction>)>,
    ui_sfx: Res<UiSfx>,
) {
    for interaction in q_button.iter() {
        match *interaction {
            Interaction::Pressed => {
                commands.spawn((
                    AudioPlayer::new(ui_sfx.on_click.clone()),
                    PlaybackSettings::DESPAWN,
                ));
            }
            Interaction::Hovered => {
                commands.spawn((
                    AudioPlayer::new(ui_sfx.on_hover.clone()),
                    PlaybackSettings::DESPAWN,
                ));
            }
            _ => (),
        }
    }
}

#[derive(EntityEvent)]
pub struct UiClick {
    entity: Entity,
}

pub fn trigger_interaction_events(
    mut commands: Commands,
    q_interactions: Query<(Entity, &Interaction), Changed<Interaction>>,
) {
    for (entity, interaction) in q_interactions.iter() {
        match *interaction {
            Interaction::Pressed => {
                commands.trigger(UiClick { entity });
            }
            _ => {}
        }
    }
}

pub struct UiFontSize;

impl UiFontSize {
    pub const HEADER: f32 = 64.;
    pub const BUTTON: f32 = 48.;
}
